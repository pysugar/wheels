# ZigZag 编码

ZigZag 编码是一种将有符号整数（包括负数）映射为无符号整数的方法，目的是优化 Varint 编码效率。
通过这种编码方式，可以使得负数也能以较小的 Varint 字节数进行编码。

## ZigZag 编码的工作原理

ZigZag 编码通过以下公式将有符号整数转换为无符号整数：

### 32 位整数 (`sint32`)

```
ZigZag(n) = (n << 1) ^ (n >> 31)
```

### 64 位整数 (`sint64`)

```
ZigZag(n) = (n << 1) ^ (n >> 63)
```

**解释**：

- `n << 1`：将整数左移一位，相当于乘以 2。
- `n >> 31` 或 `n >> 63`：算术右移，提取符号位（对于负数，结果为 -1；对于非负数，结果为 0）。
- `^`：按位异或操作。

## 编码示例

| 有符号整数 (`n`) | ZigZag 编码结果 |
|-------------------|-----------------|
| 0                 | 0               |
| -1                | 1               |
| 1                 | 2               |
| -2                | 3               |
| 2                 | 4               |
| -3                | 5               |
| ...               | ...             |

**详细步骤**：

以整数 `-1` 为例（32位）：

1. **原始值**：`n = -1`
2. **左移一位**：`n << 1` = `-2`（二进制：`11111111 11111111 11111111 11111110`）
3. **算术右移**：`n >> 31` = `-1`（二进制：`11111111 11111111 11111111 11111111`）
4. **异或**：`(-2) ^ (-1)` = `1`（二进制：`00000000 00000000 00000000 00000001`）

因此，`ZigZag(-1) = 1`。


## 反向解码

将 ZigZag 编码的无符号整数转换回有符号整数：

### 32 位整数 (`sint32`)

```
n = (ZigZag(n) >> 1) ^ -(ZigZag(n) & 1)
```

### 64 位整数 (`sint64`)

```
n = (ZigZag(n) >> 1) ^ -(ZigZag(n) & 1)
```

### 解释

- `ZigZag(n) >> 1`：右移一位，恢复原始的数值。
- `ZigZag(n) & 1`：提取最低位，确定原始数值的符号。
- `^ -`：根据最低位决定是否取反。

### 示例

解码 `ZigZag(n) = 1`：

```
n = (1 >> 1) ^ -(1 & 1) = 0 ^ -1 = -1
```

### ZigZag 编码的优势

- **高效编码**：对于小的有符号整数（包括负数），ZigZag 编码可以使其在 Varint 编码中使用更少的字节。
- **无符号整数优势**：Varint 编码对无符号整数优化更好，而 ZigZag 编码将有符号整数有效地映射为无符号整数。






